<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>동기&#x2F;비동기, 블로킹&#x2F;논블로킹 개념은 어디서부터 잘못되었나 - Sijun Yang</title>
    <meta name="description" content="Blocking + Async는 존재하지 않는다">
    <meta name="author" content="Sijun Yang">
    <link rel="stylesheet" href="/modern-css-reset.css">
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <header>
        <div class="width-wrapper">
            <nav aria-label="Primary navigation links">
                <ul>
                    <li><a href="/">About</a></li>
                    <li><a href="/blog">Blog</a></li>
                    <li><a href="/projects">Projects</a></li>
                </ul>
            </nav>
        </div>
    </header>
    
    <main class="post">
        <div class="width-wrapper">
            
<article class="page">
    
    <header class="page-header">
        <h1>동기&#x2F;비동기, 블로킹&#x2F;논블로킹 개념은 어디서부터 잘못되었나</h1>
         <p class="page-description">Blocking + Async는 존재하지 않는다</p> 
        <div class="page-meta">
            <time datetime="2025-12-11">2025년 12월 11일</time>
        </div>
    </header>

    <div class="page-content">
        <p>여러 개발 관련 글에서 Blocking/Non-blocking과 Sync/Async를 설명할 때면 항상 등장하는 2x2 매트릭스가 있다. 4개의 조합으로 나누어 설명하는 이 표를 한 번쯤은 보았을 것이다.</p>
<p><img src="/blog/sync-async-matrix.png" alt="Blocking/Non-blocking, Sync/Async 비교 매트릭스" /></p>
<p>이 매트릭스에서 가장 이해하기 어려운 부분은 Blocking + Async 조합이다. 많은 블로그에서 이 조합을 설명하려고 시도하지만, 나는 대부분 억지스러운 설명이라는 인상을 받았다.</p>
<p>최근 이 개념을 다시 공부하다가 이러한 설명은 올바르지 않다는 사실을 알게 되었다. 우리가 그동안 별 의심없이 받아들였던 이 설명이 잘못된 이유를 말해보고자 한다.</p>
<h2 id="jalmosdoen-seolmyeongyi-culceo">잘못된 설명의 출처</h2>
<p>이러한 매트릭스 기반의 설명의 시작은 IBM Developer의 2006년 글 "Boost application performance using asynchronous I/O"인 것으로 보인다.<sup class="footnote-reference" id="fr-1-1"><a href="#fn-1">1</a></sup></p>
<p><img src="/blog/ibm-io-comparison.png" alt="원래 글의 비교" /></p>
<p>IBM의 글은 리눅스 커널의 AIO(Asynchronous I/O) API를 소개하면서 sync/async와 blocking/non-blocking을 조합해 4가지로 구분했다.</p>
<p>그러나 이 글의 구분은 POSIX 표준 정의와는 다르다. 이 글에선 <code>select</code>/<code>poll</code>를 blocking + async의 조합으로 소개하지만, POSIX 표준 정의에는 이런 조합이 등장할 수 없다.</p>
<p>IBM의 글은 리눅스 커널의 AIO API를 소개하는 글이다. 리눅스 커널은 POSIX 표준을 구현하므로, 커널 레벨 I/O를 논한다면 POSIX 정의와 일관되어야 한다. 그러나 IBM의 분류는 POSIX 표준과 일치하지 않는다.</p>
<h2 id="posix-pyojunyi-silje-jeongyi">POSIX 표준의 실제 정의</h2>
<p>POSIX 표준<sup class="footnote-reference" id="fr-2-1"><a href="#fn-2">2</a></sup><sup class="footnote-reference" id="fr-3-1"><a href="#fn-3">3</a></sup>과 리처드 스티븐스(W. Richard Stevens)의 책 Unix Network Programming<sup class="footnote-reference" id="fr-4-1"><a href="#fn-4">4</a></sup>을 살펴보면 명확한 정의를 찾을 수 있다.</p>
<ul>
<li>Synchronous I/O: I/O 작업이 완료될 때까지 요청 프로세스가 blocked</li>
<li>Asynchronous I/O: 요청 프로세스가 blocked되지 않음</li>
<li>Blocking: 요청한 동작이 완료될 때까지 함수 호출이 대기</li>
<li>Non-blocking: 요청한 동작을 즉시 완료할 수 없으면 지연 없이 반환</li>
</ul>
<p>여기서 중요한 점은 I/O 작업 완료의 의미다.</p>
<h2 id="unix-i-o-modelyi-du-dangye">Unix I/O 모델의 두 단계</h2>
<p>I/O 작업은 일반적으로 두 단계로 이루어진다:</p>
<ol>
<li>데이터 준비 단계 - 디스크에서 데이터를 읽거나 네트워크에서 패킷이 도착하기를 기다린다. 데이터가 준비되면 커널 버퍼로 복사된다.</li>
<li>데이터 복사 단계 - 커널 버퍼에서 애플리케이션 버퍼로 데이터를 복사한다.</li>
</ol>
<p>스티븐스는 Unix에서 사용 가능한 5가지 I/O 모델을 다음과 같이 구분한다. 이 모델은 커널이 I/O 준비와 수행을 어떻게 관여하느냐에 따른 대표적인 분류이다. 상호 배타적인 조합표를 의미하지 않는다.<sup class="footnote-reference" id="fr-5-1"><a href="#fn-5">5</a></sup></p>
<h3 id="1-blocking-i-o">1. Blocking I/O</h3>
<p><img src="/blog/blocking-io-model.png" alt="Blocking I/O 모델의 Flow" /></p>
<p>가장 흔한 I/O 모델이다. <code>read()</code> 시스템 콜을 호출하면 데이터가 준비되고 복사가 완료될 때까지 프로세스가 block된다.</p>
<h3 id="2-non-blocking-i-o">2. Non-blocking I/O</h3>
<p><img src="/blog/nonblocking-io-model.png" alt="Non-blocking I/O 모델의 Flow" /></p>
<p><code>O_NONBLOCK</code> 플래그를 설정하면 데이터가 준비되지 않았을 때 <code>EAGAIN</code> 에러와 함께 즉시 반환한다. 하지만 데이터가 준비되면 복사하는 동안은 여전히 block된다.</p>
<h3 id="3-i-o-multiplexing">3. I/O Multiplexing</h3>
<p><img src="/blog/io-multiplexing-model.png" alt="I/O Multiplexing 모델의 Flow" /></p>
<p><code>select()</code>나 <code>poll()</code>을 사용해 여러 file descriptor를 동시에 감시한다. 준비된 fd에 대해 <code>read()</code>를 호출할 때 여전히 block된다.</p>
<h3 id="4-signal-driven-i-o">4. Signal-Driven I/O</h3>
<p><img src="/blog/signal-driven-io-model.png" alt="Signal-Driven I/O 모델의 Flow" /></p>
<p><code>SIGIO</code> 신호를 등록하고 데이터가 준비되면 신호를 받는다. 신호를 받은 후 <code>read()</code>를 호출하면 여전히 block된다.</p>
<h3 id="5-asynchronous-i-o">5. Asynchronous I/O</h3>
<p><img src="/blog/async-io-model.png" alt="Asynchronous I/O 모델의 Flow" /></p>
<p>진정한 비동기 I/O다. <code>aio_read()</code><sup class="footnote-reference" id="fr-7-1"><a href="#fn-7">6</a></sup>는 즉시 반환되고, 커널이 백그라운드에서 두 단계를 모두 처리한 후 완료를 통지한다.</p>
<h2 id="synchronous-vs-asynchronousyi-haegsim">Synchronous vs Asynchronous의 핵심</h2>
<p><img src="/blog/io-models-comparison.png" alt="5가지 I/O 모델의 비교표" /></p>
<p>스티븐스는 Unix Network Programming에서 이 모델들의 동기/비동기 여부를 명확하게 구분한다.</p>
<blockquote>
<p>POSIX defines these two terms as follows:</p>
<p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.<br />
An asynchronous I/O operation does not cause the requesting process to be blocked.<br />
Using these definitions, the first four I/O models (blocking, nonblocking, I/O multiplexing, and signal-driven I/O) are all synchronous because the actual I/O operation (recvfrom) blocks the process. Only the asynchronous I/O model matches the asynchronous I/O definition.</p>
</blockquote>
<p>다음과 같이 번역할 수 있다.</p>
<blockquote>
<p>POSIX는 이 두 용어를 다음과 같이 정의한다:</p>
<p>동기 I/O(synchronous I/O) 작업은 해당 I/O 작업이 완료될 때까지 요청한 프로세스를 블로킹한다.<br />
비동기 I/O(asynchronous I/O) 작업은 요청한 프로세스를 블로킹하지 않는다.<br />
이 정의에 따르면, 처음 네 가지 I/O 모델(블로킹 I/O, 논블로킹 I/O, I/O 멀티플렉싱, 시그널 기반 I/O)은 모두 동기 I/O에 해당한다. 실제 I/O 연산인 <code>recvfrom</code> 호출이 프로세스를 블로킹하기 때문이다.
오직 비동기 I/O 모델만이 POSIX에서 정의한 비동기 I/O에 해당한다.</p>
</blockquote>
<h3 id="5gaji-i-o-modelyi-donggi-bidonggi-bunryu">5가지 I/O 모델의 동기/비동기 분류</h3>
<table><thead><tr><th>I/O 모델</th><th>Blocking/Non-blocking</th><th>Sync/Async</th><th>1단계 Block</th><th>2단계 Block</th></tr></thead><tbody>
<tr><td>Blocking I/O</td><td>Blocking</td><td>Synchronous</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Non-blocking I/O</td><td>Non-blocking</td><td>Synchronous</td><td>No (폴링)</td><td>Yes</td></tr>
<tr><td>I/O Multiplexing</td><td>Blocking</td><td>Synchronous</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Signal-driven I/O</td><td>Non-blocking</td><td>Synchronous</td><td>No (신호)</td><td>Yes</td></tr>
<tr><td>Asynchronous I/O</td><td>Non-blocking</td><td>Asynchronous</td><td>No</td><td>No</td></tr>
</tbody></table>
<p>앞의 네 가지 모델은 모두 데이터 복사 단계(2단계)에서 block된다. 따라서 POSIX 정의상 모두 synchronous다. 오직 asynchronous I/O만이 두 단계 모두에서 block되지 않는다.</p>
<h3 id="wae-select-neun-synchronousinga">왜 <code>select()</code>는 synchronous인가?</h3>
<p>자료조사 과정에서 본 여러 자료에서 <code>select()</code>를 asynchronous로 설명하는 경우를 많이 보았다.</p>
<p><code>select()</code>는 여러 I/O를 동시에 처리할 수 있어서 비동기처럼 보이지만, 실제로는 다음과 같이 동작한다:</p>
<ol>
<li>프로세스가 감시할 파일 디스크립터 집합을 준비한다.</li>
<li><code>select()</code>는 각 파일 디스크립터가 I/O를 수행해도 블로킹되지 않을 상태인지를 알려준다.</li>
<li>준비된 파일 디스크립터에 대해 애플리케이션이 <code>read()</code>를 직접 호출한다.</li>
</ol>
<p>이때 <code>read()</code> 호출은 시스템 콜이 완료될 때까지 호출자를 반환하지 않으며, POSIX 정의상 요청한 프로세스를 블로킹하므로 synchronous가 된다.</p>
<p>멀티스레드 환경에서도 마찬가지다. I/O를 수행하는 스레드는 시스템 콜이 완료될 때까지 블로킹되며, POSIX 정의에 따르면 이는 동기 I/O다.
스레드 분리는 애플리케이션 레벨의 동시성 전략일 뿐이다. 커널의 I/O 모델을 바꿀 수는 없다.</p>
<p>Linux man page도 <code>select</code>를 "synchronous I/O multiplexing"으로 명시하고 있다.<sup class="footnote-reference" id="fr-6-1"><a href="#fn-6">7</a></sup> 반면 <code>io_uring</code><sup class="footnote-reference" id="fr-8-1"><a href="#fn-8">8</a></sup>이나 POSIX <code>aio_</code><sup class="footnote-reference" id="fr-7-2"><a href="#fn-7">6</a></sup> 함수들은 "Asynchronous I/O"로 구분한다.</p>
<h2 id="keoneol-i-o-gaenyeomgwa-peurogeuraeming-modelyi-hondong">커널 I/O 개념과 프로그래밍 모델의 혼동</h2>
<p>IBM의 글은 리눅스 커널 레벨 I/O를 다루는 기술 문서다. 커널 레벨에서 이 용어들은 POSIX 표준에 따라 엄밀하게 정의된다.
반면 애플리케이션 레벨에서는 동일한 용어가 더 느슨하고 범용적인 의미로 사용된다.
(커널은 프로세스의 실행 흐름을 정확히 제어해야 하므로 용어가 엄밀하게 정의되지만,
수많은 라이브러리와 프레임워크가 독립적으로 개발되는 애플리케이션 레벨의 라이브러리/프레임워크, 언어 등은 용어 통일이 현실적으로 불가능하다.)</p>
<p>하지만 IBM의 글이 널리 인용되면서 두 가지 문제가 발생했다.</p>
<p>첫째, 분류 방식이 POSIX 표준 정의와 정확히 일치하지 않았다. 커널 API를 다루는 글임에도 커널이 따르는 표준과 다른 기준을 사용했고,
이 설명이 반복 인용되면서 표준과 다른 내용이 사실처럼 확산되었다.<br />
둘째, 이후 수많은 블로그와 기술 문서들이 이 2×2 매트릭스를 인용하면서 원래의 맥락을 잃었다.
커널 레벨 I/O를 설명하기 위한 용어가 애플리케이션 레벨의 프로그래밍 모델이나 아키텍처의 설명까지 무분별하게 적용되었다.</p>
<p>대표적인 오해는 Node.js + MySQL 드라이버의 예시다.</p>
<blockquote>
<p>“Node.js + MySQL은 Blocking + Async의 예시다. Node.js는 비동기인데 MySQL 드라이버가 블로킹이라서…”</p>
</blockquote>
<p>이 설명은 서로 다른 레벨의 개념을 혼합한 것이다.</p>
<ul>
<li>Node.js의 비동기: 이벤트 루프 기반의 프로그래밍 모델</li>
<li>MySQL 드라이버의 블로킹: 라이브러리 차원의 API 구현 방식</li>
</ul>
<p>이는 커널 레벨의 I/O 동작과는 직접적인 관련이 없으며, 애초에 IBM 문서가 다루던 맥락과도 다르다.
이처럼 추상화 레벨이 다른 개념들을 구분 없이 동일한 용어로 설명하다 보니, 개념적 혼란이 발생할 수밖에 없다.</p>
<h2 id="peurogeuraeming-modelroseoyi-bidonggigwa-naebu-guhyeon">프로그래밍 모델로서의 비동기과 내부 구현</h2>
<p>많은 비동기 프로그래밍 모델을 제공하는 프레임워크들이 내부 구현에선 동기 시스템 콜을 사용한다.</p>
<p>Netty는 "asynchronous event-driven" 프레임워크를 표방하지만<sup class="footnote-reference" id="fr-10-1"><a href="#fn-10">9</a></sup>, 실제로는 <code>epoll()</code>이나 <code>kqueue</code> 같은 I/O multiplexing을 사용한다. 이들은 POSIX 정의상 synchronous다.<br />
Node.js도 마찬가지다. libuv를 통해 플랫폼별로 최적화된 I/O multiplexing을 사용하거나, 파일 시스템 작업의 경우 별도 스레드 풀에서 blocking I/O를 수행한다.<sup class="footnote-reference" id="fr-9-1"><a href="#fn-9">10</a></sup><br />
이것이 잘못된 설명이나 구현은 아니다. 애플리케이션 개발자 입장에서는 비동기 프로그래밍 모델을 제공받는 것이 중요하지, 내부적으로 어떤 시스템 콜을 사용하는지는 중요하지 않다.</p>
<h2 id="gyeolron">결론</h2>
<p>POSIX 표준에 따르면 I/O 모델은 본질적으로 세 가지로 구분할 수 있다.</p>
<ol>
<li>Blocking Synchronous - 전통적인 blocking I/O와 I/O multiplexing</li>
<li>Non-blocking Synchronous - non-blocking I/O와 signal-driven I/O</li>
<li>Asynchronous - 진정한 비동기 I/O (POSIX aio, io_uring)</li>
</ol>
<p>따라서 Blocking + Async라는 조합은 정의상 존재할 수 없다. Asynchronous는 정의상 어떤 단계에서도 block되지 않기 때문이다.</p>
<p>물론 애플리케이션 레벨에서는 이 구분이 덜 엄격하다. 프로그래밍 모델로서의 비동기와 시스템 콜 레벨의 비동기는 다른 개념이며, 이를 명확히 구분해야 한다.
Netty나 Node.js 같은 프레임워크가 비동기를 표방하는 것은 애플리케이션 개발자에게 제공하는 프로그래밍 모델을 지칭하는 것이지, POSIX I/O 모델의 정의를 따르는 것이 아니다.</p>
<p>중요한 것은 맥락이다. OS나 커널 레벨의 I/O를 논할 때와 애플리케이션 레벨의 프로그래밍 패턴을 논할 때, 같은 용어가 다른 의미를 가질 수 있다. 이러한 차이를 인지하고 명확히 구분해서 사용해야 불필요한 혼란을 피할 수 있다.</p>
<h2 id="naneun-eoddeohge-gubunhaneunga">나는 어떻게 구분하는가</h2>
<p>커널 I/O 레벨에선 표준의 정의를 따른다.</p>
<ul>
<li>동기 / 비동기: I/O 작업이 완료될 때까지 요청 프로세스가 블로킹되는지 여부</li>
<li>블로킹 / 논블로킹: 요청한 동작을 즉시 완료할 수 없을 때 함수 호출이 대기하는지 여부</li>
</ul>
<p>다만 시스템 레벨 개발을 주로 하지 않기 때문에, 이 용어를 쓸 일은 많지 않다.
이 레벨에서는 추상적인 용어보다 select, epoll, io_uring 같은 구체적인 시스템 콜 이름으로 대화하는 것이 더 명확하다고 생각한다.</p>
<p>어플리케이션 레벨에선 다음 기준으로 구분한다.</p>
<ul>
<li>동기 / 비동기: 애플리케이션 레벨에서의 프로그래밍 모델, 전체 실행 흐름</li>
<li>블로킹 / 논블로킹: 함수 호출이나 개별 작업 단위에서의 동작</li>
</ul>
<p>일반적으로 이 관점에서 이야기한다. 이렇게 구분하면 아키텍처를 설명하거나 문제를 분석할 때 명확하게 생각할 수 있다.<br />
예를 들어, “비동기 모델 환경에서 블로킹 호출을 사용해 전체 실행 흐름에 영향을 주었다.”, “동기 환경이더라도 오래 걸리는 I/O를 논블로킹으로 처리해 효율을 높일 수 있다.” 와 같이 모델과 동작을 분리해서 생각할 수 있다.</p>
<h2 id="burog">부록</h2>
<p>"Boost application performance using asynchronous I/O" 를 포함한 IBM Developer의 오래된 글이 아카이브되어 원래 작성 시점을 알 수 없었는데, <a rel="external" href="https://www.cyberciti.biz/tips/linux-boost-application-performance-using-asynchronous-io.html">저자의 사이트에서 원본 자료가 링크된 글</a>을 보고 2006년 작성되었다고 추정했다.</p>
<p>IBM의 설명이 한국에만 퍼진 이야기는 아닌 듯 하다. 영어, 중국어나 일본어로 작성된 자료에서도 2x2 매트릭스를 사용해 구분하는 글을 찾아볼 수 있었다.</p>
<p>조사 과정에서 참고한 자료들이다. 높은 신뢰성을 가지는 문서는 아니지만 개념을 이해하는 데 도움이 되어 남겨두었다.</p>
<ul>
<li><a rel="external" href="https://www.linuxquestions.org/questions/programming-9/asynchronized-i-o-%3D%3D-multiplexing-i-o-467044/">Asynchronized I/O vs Multiplexing I/O 토론 - Linux Questions</a></li>
<li><a rel="external" href="https://www.artima.com/articles/comparing-two-high-performance-io-design-patterns">Comparing Two High-Performance I/O Design Patterns</a></li>
<li><a rel="external" href="https://youtu.be/EJNBLD3X2yg">비동기 프로그래밍, 비동기 I/O, 비동기 커뮤니케이션 - 쉬운코드 (YouTube)</a></li>
<li><a rel="external" href="https://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/">Blocking-NonBlocking-Synchronous-Asynchronous - 뒤태지존의 끄적거림</a></li>
<li><a rel="external" href="https://www.reddit.com/r/rust/comments/1pn6010/compio_instead_of_tokio_what_are_the_implications/">Tokio와 Compio의 차이: 비동기 모델(epoll vs io_uring) - Reddit</a></li>
<li><a rel="external" href="https://www.inflearn.com/course/%EA%B8%B0%EC%B4%88%ED%83%84%ED%83%84-%EB%8F%85%ED%95%98%EA%B2%8C-java-part3-2">기초 탄탄! 독하게 시작하는 Java Part 3(하) : 소켓과 파일 I/O 강의 | 널널한 개발자 - 인프런</a></li>
</ul>
<h2 id="references">References</h2>
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn-1">
<p>M. Tim Jones, <a rel="external" href="https://developer.ibm.com/articles/l-async/">"Boost application performance using asynchronous I/O"</a>, IBM Developer, 2006. <a href="#fr-1-1">↩</a></p>
</li>
<li id="fn-2">
<p>IEEE Std 1003.1-2024, <a rel="external" href="https://pubs.opengroup.org/onlinepubs/9799919799/">"The Open Group Base Specifications Issue 8"</a>, IEEE and The Open Group, 2024. <a href="#fr-2-1">↩</a></p>
</li>
<li id="fn-3">
<p>IEEE Std 1003.1-2004, <a rel="external" href="https://pubs.opengroup.org/onlinepubs/009695399/">"The Open Group Base Specifications Issue 6"</a>, IEEE and The Open Group, 2004. <a href="#fr-3-1">↩</a></p>
</li>
<li id="fn-4">
<p>W. Richard Stevens, Bill Fenner, Andrew M. Rudoff, "Unix Network Programming, Volume 1: The Sockets Networking API", 3rd Edition, Addison-Wesley, 2003. <a href="#fr-4-1">↩</a></p>
</li>
<li id="fn-5">
<p>예를 들면, I/O Multiplexing과 Non-blocking I/O 모델을 함께 사용할 수도 있다. <code>select()</code> 함수는 기본적으로 이벤트가 올때까지 wait하는 blocking 함수인데, fb에 <code>O_NONBLOCK</code> 플래그를 활성화 해서 Non-blocking 함수로 동작하게 할 수 있다. 이 경우, 여러 fb를 동시에 감시하면서 데이터의 준비 여부와 무관하게 즉시 반환된다. <a href="#fr-5-1">↩</a></p>
</li>
<li id="fn-7">
<p>Linux man pages, <a rel="external" href="https://man7.org/linux/man-pages/man7/aio.7.html">"aio(7) - POSIX asynchronous I/O overview"</a> <a href="#fr-7-1">↩</a> <a href="#fr-7-2">↩2</a></p>
</li>
<li id="fn-6">
<p>Linux man pages, <a rel="external" href="https://man7.org/linux/man-pages/man2/select.2.html">"select(2) - synchronous I/O multiplexing"</a> <a href="#fr-6-1">↩</a></p>
</li>
<li id="fn-8">
<p>Linux man pages, <a rel="external" href="https://man7.org/linux/man-pages/man7/io_uring.7.html">"io_uring(7) - Asynchronous I/O facility"</a> <a href="#fr-8-1">↩</a></p>
</li>
<li id="fn-10">
<p>Netty Project, <a rel="external" href="https://github.com/netty/netty/blob/4.2/README.md">"Netty v4.2 README"</a>, GitHub <a href="#fr-10-1">↩</a></p>
</li>
<li id="fn-9">
<p>libuv documentation, <a rel="external" href="https://docs.libuv.org/en/v1.x/design.html">"Design overview"</a> <a href="#fr-9-1">↩</a></p>
</li>
</ol>
</section>

    </div>
</article>

<!-- For Utterances -->
<section class="comments">
    
    <noscript>댓글을 보려면 JavaScript를 활성화해주세요.</noscript>

    <script src="https://utteranc.es/client.js"
            repo="yangsijun528/sijun-yang.com"
            issue-term="pathname"
            label="utterances-comment"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    

    <div class="comments-skeleton"></div>

    <script>
        const observer = new MutationObserver(_ => {
            const utterances = document.querySelector('.utterances');
            if (utterances) {
                const height = utterances.offsetHeight;
                if (height > 200) {
                    document.querySelector('.comments').classList.add('comments-loaded');
                    observer.disconnect();
                }
            }
        });

        observer.observe(document.querySelector('.comments'), {
            childList: true, subtree: true, attributes: true, attributeFilter: ['style']
        });
    </script>
</section>

        </div>
    </main>

    <footer>
        <div class="width-wrapper">
            <p>
                Built with <a href="https://www.getzola.org/">Zola</a> -
                <a href="https://github.com/YangSiJun528/sijun-yang.com">Source Code</a>
            </p>
            <nav aria-label="Footer links">
                <ul>
                    <li><a href="/rss.xml">RSS</a></li>
                    <li><a href="/sitemap.xml">Sitemap</a></li>
                    <li><a href="/robots.txt">robots.txt</a></li>
                </ul>
            </nav>
        </div>
    </footer>
</body>
</html>
