<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>시간 데이터를 올바르게 다루는 방법 - Sijun Yang</title>
    <meta name="description" content="">
    <meta name="author" content="Sijun Yang">
    <link rel="stylesheet" href="/modern-css-reset.css">
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <header>
        <div class="width-wrapper">
            <nav aria-label="Primary navigation links">
                <ul>
                    <li><a href="/">About</a></li>
                    <li><a href="/blog">Blog</a></li>
                    <li><a href="/projects">Projects</a></li>
                </ul>
            </nav>
        </div>
    </header>
    
    <main class="post">
        <div class="width-wrapper">
            
<article class="page">
    
    <header class="page-header">
        <h1>시간 데이터를 올바르게 다루는 방법</h1>
        
        <div class="page-meta">
            <time datetime="2026-01-12">2026년 01월 12일</time>
        </div>
    </header>

    <div class="page-content">
        <p>프로그래밍을 어느 정도 해봤다면, 시간 관련 버그를 한 번쯤은 겪거나 들어보았을 것이다.
서버 환경을 바꾸니 시간이 9시간 밀린다거나, 로컬에서는 잘 되던 게 배포만 하면 시간이 이상하게 보인다거나.</p>
<p>이런 버그가 종종 보이는 이유는 단순한 문자열<sup class="footnote-reference" id="fr-1-1"><a href="#fn-1">1</a></sup>이나 정수형 타입과 다르게 시간 데이터의 다루는 데 생각보다 많은 주의사항이 존재하기 때문이다<sup class="footnote-reference" id="fr-2-1"><a href="#fn-2">2</a></sup>.</p>
<p>이 글에서는 시간 데이터의 두 가지 타입과 관련 문제들을 살펴본 뒤, 내가 사용하는 두 가지 원칙을 소개한다.
마지막으로 이 원칙에 영향을 준 JavaScript Temporal API를 간단히 다룬다.</p>
<p>익숙한 Java/JavaScript 생태계를 중심으로 설명하지만, 모든 언어에 적용 가능하다.</p>
<h2 id="siganyi-2gaji-taib">시간의 2가지 타입</h2>
<p>시간 데이터는 크게 두 종류로 나눌 수 있다.</p>
<p><strong>Exact Time(물리적 순간)</strong>: 유일한 하나의 시점을 가리킨다.
"2024-01-01T00:00:00+00:00"는 전 세계 어디서든 같은 순간이다.
Unix timestamp나 UTC 오프셋을 포함한 ISO 8601 형식(예: 2024-01-01T00:00:00Z)이 여기에 해당한다.<br />
<strong>Wall-clock Time(벽시계 시간)</strong>: 특정 시점이 아니라 날짜와 시간 값 자체를 의미한다.
"12월 25일"은 뉴욕 시간이나 한국 시간처럼 특정 지역의 시간을 의미하지 않는다.</p>
<p>JavaScript의 Temporal API가 이 개념을 잘 설명해서, 이 글에서도 Temporal의 용어를 차용하여 설명한다.</p>
<h2 id="sigan-deiteoreul-darul-ddae-juyihaeya-hal-jeom">시간 데이터를 다룰 때 주의해야 할 점</h2>
<h3 id="taimjon-jeongbo-sonsil">타임존 정보 손실</h3>
<p>Java의 <code>LocalDateTime</code>은 <code>Local-</code>로 시작하는 이름에서 유추할 수 있듯이 타임존 정보를 저장하지 않는다.
하지만 <code>LocalDateTime.now()</code>를 호출하면 시스템의 기본 타임존을 사용해서 현재 시각을 가져온다<sup class="footnote-reference" id="fr-3-1"><a href="#fn-3">3</a></sup>.
Python의 <code>datetime.now()</code>나 C#의 <code>DateTime.Now</code>도 비슷하게 절대 시점을 저장하지 않는다.</p>
<p>이러한 함수를 보았을 때 타임존 변환이 일어났는지 알기 어렵다. 또한 내부 구현에서 타임존 정보를 유지하지 않는다.
객체 생성하는 도중 타임존을 사용해서 변환은 했지만, 결과 객체에선 어떤 타임존이었는지는 저장하지 않는 것이다.
그래서 이 값을 직렬화하거나 저장하면 어느 지역의 시간인지 알 수 없게 된다.
직렬화할 때 로컬의 시간대 정보를 함께 보내면 되지 않나 싶지만,
<code>now()</code> 호출 시 타임존을 직접 지정하는 것도 가능하기 때문에 선언 시점을 제외하면 어떤 타임존이었는지 알 방법이 없다.</p>
<p>특히 요즘의 서비스에선 아주 많은 "로컬"이 존재할 수 있다.
클라이언트와 서버만 있는 간단한 웹 서비스도 2개의 노드가 존재한다.
MSA 서비스라면 LB, DB, Redis, 모니터링 등 서버만 수십 개가 넘어갈 수도 있다.
이때 타임존 없는 시간 문자열을 주고받으면, 원래 어떤 타임존이었는지 복구할 방법이 없다.</p>
<h3 id="yeoreo-gisulyi-hamjeong">여러 기술의 함정</h3>
<p>다양한 기술 스택에서 타임존 처리와 관련된 함정들이 존재한다.
직렬화 라이브러리, ORM, DB 등에서 타임존 관련 기본 설정이나 옵션이 직관적이지 않아 의도하지 않은 동작을 유발할 수 있다.
몇가지 예시를 살펴보자.</p>
<h4 id="jackson">Jackson</h4>
<p><code>DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE</code><sup class="footnote-reference" id="fr-4-1"><a href="#fn-4">4</a></sup>은 기본적으로 true로 설정되어 있는데,
이 옵션이 활성화되어 있으면 <code>ZonedDateTime</code>이나 <code>OffsetDateTime</code>을 역직렬화할 때 원본 타임존을 컨텍스트 타임존(기본값 UTC)으로 변환한다.
이 과정에서 시점 정보는 유지되지만, 원래 타임존 정보를 잃어버린다 (이 옵션은 Jackson 3버전 부터 <code>DateTimeFeature</code> 객체로 이관되었다<sup class="footnote-reference" id="fr-5-1"><a href="#fn-5">5</a></sup>).</p>
<h4 id="ansi-sqlyi-timestamp-with-time-zone">ANSI SQL의 TIMESTAMP WITH TIME ZONE</h4>
<p>ANSI SQL 표준의 <code>TIMESTAMP WITH TIME ZONE</code> 데이터 타입은 이름과 달리 타임존 정보를 유지해야 한다는 요구사항이 없다<sup class="footnote-reference" id="fr-6-1"><a href="#fn-6">6</a></sup>.
그래서 Oracle의 경우 타임존 정보를 저장하는 반면, PostgreSQL은 타임존 정보를 저장하지 않는 등 제각각의 구현이 존재한다.</p>
<p>PostgreSQL을 자세하게 설명해보자면,
데이터 타입 <code>timestamp</code>(<code>timestamp without time zone</code>)는 문자열로 Wall-clock Time 정보를 저장한다. 그래서 시간 비교 등의 연산에서 취약하다<sup class="footnote-reference" id="fr-7-1"><a href="#fn-7">7</a></sup>.
Exact Time을 저장하려면 <code>timestamptz</code>(<code>timestamp with time zone</code>)를 사용해야 하는데, UTC로 변환되어 저장되고 타임존 정보는 유지되지 않는다.
또한 조회 시 세션의 타임존에 의존하여 시간 결과를 반환한다.</p>
<h4 id="jpawa-hibernate">JPA와 Hibernate</h4>
<p>Hibernate는 6.0 이후부터 <code>LocalDateTime</code>은 <code>TIMESTAMP</code>, <code>Instant</code>는 <code>TIMESTAMP_UTC</code>로 매핑된다<sup class="footnote-reference" id="fr-8-1"><a href="#fn-8">8</a></sup>.
<code>TIMESTAMP_UTC</code>는 저장 시 값을 UTC로 정규화하지만, <code>TIMESTAMP</code>는 변환 없이 그대로 저장된다.
즉, 두 타입을 Exact Time 표현용과 Wall-clock Time 표현용으로 구분하고 있다.</p>
<p>Hibernate는 <code>LocalDateTime</code>을 DB에 저장할 때 JVM 기본 타임존을 기준으로 <code>java.sql.Timestamp</code>로 변환한 뒤 UTC로 정규화한다.
이 과정에서 원본 타임존 정보가 사라진다.
여러 DB 접근 라이브러리를 함께 사용하는 환경에서는 각 라이브러리의 타임존 설정 차이로 인해 시간 오차가 발생할 수 있다<sup class="footnote-reference" id="fr-9-1"><a href="#fn-9">9</a></sup>.</p>
<p>Spring Data 개발자 Jens Schauder 역시 <code>LocalDateTime</code>은 타임라인 상의 특정 순간을 표현할 수 없으므로 <code>Instant</code>를 사용하는 것이 바람직하다고 설명한다<sup class="footnote-reference" id="fr-10-1"><a href="#fn-10">10</a></sup>.</p>
<p>그럼에도 불구하고 많은 코드에서 여전히 Exact Time 데이터를 <code>LocalDateTime</code>으로 선언해 사용하고 있다
(예: <a rel="external" href="https://github.com/team-dodn/spring-boot-java-template/blob/750675f8bb7bc97b644e18576a5b26148ac65e17/storage/db-core/src/main/java/io/dodn/springboot/storage/db/core/BaseEntity.java">spring-boot-java-template BaseEntity의 createdAt, updatedAt</a>).</p>
<h2 id="sigan-deiteoreul-daruneun-2gaji-weoncig">시간 데이터를 다루는 2가지 원칙</h2>
<p>나는 시간 데이터를 다룰 때 두 가지 원칙을 기준으로 삼고 있다.</p>
<p>이걸 꼭 따라야 한다는 말은 아니다.
하지만 "모든 노드(클라이언트, 서버, DB, 캐시 등)에서 시간 데이터에 대한 해석이 일관되어야 한다."는 조건을 만족하려면 이 원칙과 비슷한 결론에 도달할 것이다.</p>
<h3 id="weoncig-1-exact-timegwa-wall-clock-timeeul-myeonghwaghi-gubunhara">원칙 1: Exact Time과 Wall-clock Time을 명확히 구분하라</h3>
<p>시간 데이터가 특정 시점을 나타내는지, 아니면 단순한 날짜/시간 값인지 먼저 판단해야 한다.</p>
<p>로그 타임스탬프, 결제 완료 시각, 이벤트 발생 시각처럼 "언제 일어났는가"가 중요한 데이터는 Exact Time으로 저장한다.
Exact Time이 아니면 정확한 시점을 알 수 없기 때문이다.
<code>LocalDateTime.now()</code>처럼 타임존 정보가 사라지는 방식으로 저장하면, 나중에 원래 시점을 복구할 방법이 없다.</p>
<p>생일, 기념일, 공휴일처럼 특정 시점이라는 개념 자체가 없는 데이터는 Wall-clock Time으로 저장해서 날짜/시간 값 자체만 저장한다.
이런 데이터를 Exact Time으로 다루면 오히려 문제가 생길 수 있다.</p>
<p>단, 이 기준은 도메인에 따라 달라진다.
산부인과 병원 시스템이라면 출생아의 생일이 출생 시점(Exact Time)으로 관리되어야 할 수 있다.</p>
<h4 id="jeojang-pomaes">저장 포맷</h4>
<p>각 타입에 적합한 저장 포맷을 사용해야 한다.</p>
<p>Exact Time:</p>
<ul>
<li>Unix timestamp (밀리초 또는 초 단위 정수)</li>
<li>PostgreSQL의 <code>TIMESTAMPTZ</code></li>
<li>ISO 8601 with offset (예: <code>2024-01-01T00:00:00Z</code>)</li>
</ul>
<p>Wall-clock Time:</p>
<ul>
<li><code>DATE</code> 타입 (예: <code>2024-12-25</code>)</li>
<li><code>TIME</code> 타입 (예: <code>14:30:00</code>)</li>
<li>문자열 (예: <code>"2024-12-25"</code>, <code>"14:30"</code>)</li>
</ul>
<h4 id="taib-gaegce-seoneon-sijeom-juyisahang">타입 객체 선언 시점 주의사항</h4>
<p>대부분의 시간 관련 버그는 코드에서 시간 타입을 생성할 때 발생하므로 주의 깊게 보아야 한다.</p>
<ul>
<li>Exact Time이 필요한 곳에서 <code>LocalDateTime.now()</code>를 쓰고 있지는 않은지 확인한다.
<code>Instant.now()</code> 또는 <code>System.currentTimeMillis()</code>를 사용해야 한다.</li>
<li>Wall-clock Time이 필요한 곳에서 UTC 변환을 하고 있지는 않은지 확인한다.
<code>LocalDate.of(2024, 12, 25)</code>처럼 날짜 값 자체만 저장해야 한다.</li>
</ul>
<h3 id="weoncig-2-exact-timeeun-utcro-jeojanghago-taimjoneun-byeoldo-gwanrihara">원칙 2: Exact Time은 UTC로 저장하고, 타임존은 별도 관리하라</h3>
<p>Exact Time 데이터는 저장, 직렬화/역직렬화, 송수신 등 모든 과정에서 UTC 또는 Unix timestamp로 처리한다.</p>
<h4 id="taimjoni-pilyohan-gyeongu">타임존이 필요한 경우</h4>
<p>비행기 출발 시각, 회의 시간처럼 특정 지역의 시간 표현이 필요한 경우에는 Exact Time과 타임존을 별도 필드로 관리한다.</p>
<p>내부적으로는 UTC(Unix timestamp)로 저장하고, 사용자에게 보여줄 때만 해당 타임존으로 변환한다.</p>
<p>이렇게 하면 시간 비교나 집계 등의 계산이 편리해진다. 저장된 값 자체가 바뀌지 않기 때문이다.
앞서 말했듯 타임존 타입의 지원이 아직 완전하지 않거나 주의해야 하는 시스템이 존재하기 때문에<sup class="footnote-reference" id="fr-11-1"><a href="#fn-11">11</a></sup>,
모든 곳에서 타임존을 UTC로 고정하거나 타임존 정보가 없는 Exact Time인 Unix timestamp 형태로 관리하는 것이 안전하다.</p>
<h4 id="jeonsong-jeojang-sijeom-juyisahang">전송/저장 시점 주의사항</h4>
<p>DB 저장, API 직렬화 등의 과정에서 정보가 손실되는지 확인해야 한다.
명시적인 포맷이나 타입 계약이 없다면, 동일한 값이라도 시스템마다 다르게 해석될 수 있다.</p>
<p>DB 데이터 타입, gRPC 같은 스키마 기반 통신 처럼 포맷(타입) 계약이 존재하면 이를 그대로 따른다.<br />
JSON이나 텍스트 기반 통신처럼 계약이 없거나 범용 포맷이 필요한 경우,
Unix timestamp 또는 UTC 오프셋을 포함한 ISO 8601을 사용한다.</p>
<p>ISO 8601는 가독성이 높고, 대부분의 직렬화 라이브러리에서 기본 지원된다.
Unix timestamp는 숫자 자체가 절대 시각이므로 해석 오류 여지가 없고, 저장 공간도 적다.
다만 자동 변환을 지원하지 않는 환경에서는 추가 처리가 필요하다.</p>
<h4 id="dstwa-jeongcaeg-byeongyeong-daeeung">DST와 정책 변경 대응</h4>
<p>타임존과 시간대 정보가 포함된 데이터를 다루는 경우, 여러 가지 모호한 상황(Ambiguity)이 발생할 수 있다.
이와 관련된 구체적인 예시는 <a rel="external" href="https://tc39.es/proposal-temporal/docs/timezone.html">"Temporal Time Zones and Resolving Ambiguity - Temporal Proposal Documentation"</a>에서 찾을 수 있다<sup class="footnote-reference" id="fr-12-1"><a href="#fn-12">12</a></sup>.</p>
<ul>
<li>DST 시작/종료 같은 일시적 Offset 이동으로 인해서 동일한 벽시계 시간이 두 번 발생(fall back)하거나 존재하지 않는 시간(spring forward)이 생길 수 있다.</li>
<li>정책 변경으로 TimeZone 정의가 변경되어 기존에 저장된 미래 시점의 값과 새로운 규칙 간 충돌이 발생할 수 있다.</li>
</ul>
<p>지금 설명중인 2가지 원칙들을 따르면 이러한 문제 대부분을 피할 수 있다.</p>
<ul>
<li>UTC로 저장하면 DST 영향을 받지 않는다. DST는 특정 타임존의 오프셋이 변경되는 것이지, UTC 자체가 바뀌는 것이 아니기 때문이다.</li>
<li>타임존 ID를 별도 필드로 저장하면 정책 변경 시에도 올바른 현지 시간을 계산할 수 있다. IANA 타임존 데이터베이스가 업데이트되면 새로운 규칙이 자동으로 적용된다.</li>
</ul>
<h2 id="temporal-api-sogae">Temporal API 소개</h2>
<h3 id="yeogsajeog-baegyeong">역사적 배경</h3>
<p>1996년 Java 1.0에서 <code>java.util.Date</code>가 도입됐다.
이는 많은 문제가 있는 구현이였는데, 월이 0부터 시작하고 연도는 1900을 빼서 저장하고 객체가 mutable해서 언제든 값이 바뀔 수 있었다<sup class="footnote-reference" id="fr-13-1"><a href="#fn-13">13</a></sup>.</p>
<p>JavaScript가 만들어질 때, Java의 Date 구현을 거의 그대로 가져왔다<sup class="footnote-reference" id="fr-14-1"><a href="#fn-14">14</a></sup>.
Java는 이후 개선을 시도한 반면, Date는 거의 30년이 지난 지금까지 사용되고 있다. (그래서 프로덕션 환경에선 별도의 시간 라이브러리를 많이 쓴다.)</p>
<p>2002년 Stephen Colebourne이 Java Date의 문제를 보완한 Joda-Time 라이브러리를 만들었다.
Joda-Time은 큰 성공을 거뒀고, 2014년 Java 8의 공식 <code>java.time</code> 패키지(JSR-310)로 이어졌다<sup class="footnote-reference" id="fr-15-1"><a href="#fn-15">15</a></sup>.</p>
<p>JavaScript에서는 Date의 문제를 해결하기 위해 Temporal API 제안이 진행되었고,
TC39(ECMAScript 기술위원회)에서 이 제안은 Stage 3(명세가 확정되어 구현을 진행) 상태에 있다.</p>
<h3 id="temporalyi-seolgye">Temporal의 설계</h3>
<p>Temporal은 Exact Time과 Wall-clock Time의 구분을 타입 시스템에서 강제한다.</p>
<p><img src="/blog/temporal-object-model.svg" alt="Temporal Object Model" />
<a rel="external" href="https://tc39.es/proposal-temporal/docs/object-model.svg">원본 링크</a></p>
<p>위 다이어그램에서 왼쪽은 Exact Time(물리적 순간)을 아는 타입들이고, 오른쪽은 Wall-clock Time(벽시계 시간)을 아는 타입들이다.</p>
<p><code>Temporal.Instant</code>는 물리적 순간만 표현한다. 타임존이나 캘린더 없이 절대 시점만 저장한다.
<code>Temporal.ZonedDateTime</code>은 물리적 순간에 타임존과 캘린더를 더해서 양쪽에 걸쳐 있다.
반면 <code>Plain-</code> 접두사가 붙은 타입들(<code>PlainDateTime</code>, <code>PlainDate</code>, <code>PlainTime</code> 등)은 타임존 정보가 없다.</p>
<p><img src="/blog/temporal-persistence-model.svg" alt="Temporal Persistence Model" />
<a rel="external" href="https://tc39.es/proposal-temporal/docs/persistence-model.svg">원본 링크</a></p>
<p>이 다이어그램은 각 타입이 문자열로 직렬화될 때 어떤 정보가 포함되는지 보여준다.
<code>Instant</code>는 UTC 시간만, <code>ZonedDateTime</code>은 오프셋과 타임존 ID까지, <code>Plain</code> 타입들은 날짜/시간 정보만 포함된다.</p>
<h3 id="plain-vs-local">Plain vs Local</h3>
<p>여기서 "Plain"이라는 네이밍이 중요하다. java.time의 "Local"은 이름에서 위치를 암시하지만, "Plain"은 타임존에 대한 어떤 가정도 없다는 것을 명확히 보여준다.
단순하게 날짜와 시간 값 자체만을 표현한다는 의미가 더 직관적으로 드러난다. Temporal의 설계자들 역시 이러한 의도를 가지고 Plain이라는 이름을 선택했다<sup class="footnote-reference" id="fr-16-1"><a href="#fn-16">16</a></sup><sup class="footnote-reference" id="fr-17-1"><a href="#fn-17">17</a></sup>.</p>
<h3 id="temporal-nowyi-bunri">Temporal.Now의 분리</h3>
<p>Temporal은 "now"를 다루는 방식이 기존의 일반적인 라이브러리와 다르다.
<code>Temporal.Now</code>라는 별도 객체가 존재해서, <code>Temporal.Now.instant()</code>나 <code>Temporal.Now.plainDateTimeISO()</code> 같은 형태로 사용한다.
현재 시각 조회를 별도 API로 분리해서 타임존 정보 손실이 발생할 수 있다는 것을 API 표면에서 명확하게 알려준다.
반면 java.time에서는 <code>LocalDateTime.now()</code>처럼 각 타입에 now 메서드가 붙어 있어 정보 손실이 발생 가능하다는 것이 명확하지 않다.</p>
<h3 id="aemaemohohan-sanghwang-ceori">애매모호한 상황 처리</h3>
<p>Temporal은 Plain 타입에서 Exact 타입으로 변환할 때 발생하는 모호함을 다루는 방법을 개발자가 선택할 수 있게 한다<sup class="footnote-reference" id="fr-12-2"><a href="#fn-12">12</a></sup>.</p>
<p>앞서 제시한 원칙을 따르면 이런 기능이 필요한 상황 자체가 드물어진다.
다만 레거시 데이터 마이그레이션이나 사용자 입력 처리 같은 예외 상황에서는 유용하므로, 어떤 옵션을 제공하는지 알아두면 좋다.</p>
<h2 id="references">References</h2>
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn-1">
<p>사실 문자열도 그렇게 단순하지는 않다. 유니코드, 인코딩, 정규화 등 고려해야 할 사항이 많다. 이와 관련해서는 <a rel="external" href="https://tonsky.me/blog/unicode/">The Absolute Minimum Every Software Developer Must Know About Unicode in 2023</a>, <a rel="external" href="https://utf8everywhere.org/#">UTF-8 Everywhere</a>, <a rel="external" href="https://yozm.wishket.com/magazine/detail/2836/">아�니 이 글자 왜 들어간 거예요?</a> 같은 글을 읽어보는 걸 추천한다. <a href="#fr-1-1">↩</a></p>
</li>
<li id="fn-2">
<p>여기서 다루는 내용과 별개지만, 시간 데이터의 정확성 자체도 완벽하지 않다. 분산 시스템에서 "정확한 시간"을 정의하는 것 자체가 매우 어려운 문제다. 이와 관련해서는 <a rel="external" href="https://dataintensive.net/">"Designing Data-Intensive Applications"</a>, Chapter 8: 'Unreliable Clocks'를 읽어보는 것을 추천한다. <a href="#fr-2-1">↩</a></p>
</li>
<li id="fn-3">
<p>OpenJDK, <a rel="external" href="https://github.com/openjdk/jdk/blob/jdk-27%2B3/src/java.base/share/classes/java/time/LocalDateTime.java#L213">"LocalDateTime.java source code"</a>, GitHub. <a href="#fr-3-1">↩</a></p>
</li>
<li id="fn-4">
<p>Jackson, <a rel="external" href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html">"DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE"</a>, JavaDoc. <a href="#fr-4-1">↩</a></p>
</li>
<li id="fn-5">
<p>Jackson 3.0.3, <a rel="external" href="https://javadoc.io/doc/tools.jackson.core/jackson-databind/latest/tools.jackson.databind/tools/jackson/databind/cfg/DateTimeFeature.html">"DateTimeFeature"</a>, JavaDoc. <a href="#fr-5-1">↩</a></p>
</li>
<li id="fn-6">
<p>SQL-92 Standard, Section 4.5 "Datetimes and intervals" - <a rel="external" href="https://modern-sql.com/standard">Modern SQL</a>, <a rel="external" href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">Full Draft</a>. <a href="#fr-6-1">↩</a></p>
</li>
<li id="fn-7">
<p>PostgreSQL Wiki, <a rel="external" href="https://wiki.postgresql.org/wiki/Don&#x27;t_Do_This#Don&#x27;t_use_timestamp_(without_time_zone)_to_store_UTC_times">"Don't Do This"</a>. <a href="#fr-7-1">↩</a></p>
</li>
<li id="fn-8">
<p>Hibernate ORM, <a rel="external" href="https://github.com/hibernate/hibernate-orm/blob/6.0/migration-guide.adoc#instant-mapping-changes">"Instant mapping changes"</a>, Migration Guide, Version 6.0. <a href="#fr-8-1">↩</a></p>
</li>
<li id="fn-9">
<p>jOOQ GitHub, <a rel="external" href="https://github.com/jOOQ/jOOQ/issues/11753">"LocalDateTime param binding handled differently by hibernate"</a>, Issue #11753, 2021. <a href="#fr-9-1">↩</a></p>
</li>
<li id="fn-10">
<p>Jens Schauder, <a rel="external" href="https://blog.schauderhaft.de/2018/03/14/dont-use-localdatetime/">"Don't use LocalDateTime"</a>, Schauderhaft Blog, 2018. <a href="#fr-10-1">↩</a></p>
</li>
<li id="fn-11">
<p>Hibernate ORM Discussion, <a rel="external" href="https://github.com/hibernate/hibernate-orm/discussions/4201#discussioncomment-1291666">"Support timestamp with timezone/offset"</a>, GitHub. <a href="#fr-11-1">↩</a></p>
</li>
<li id="fn-12">
<p>TC39, <a rel="external" href="https://tc39.es/proposal-temporal/docs/timezone.html">"Temporal Time Zones and Resolving Ambiguity"</a>, Temporal Proposal Documentation. <a href="#fr-12-1">↩</a> <a href="#fr-12-2">↩2</a></p>
</li>
<li id="fn-13">
<p>Oracle, <a rel="external" href="https://docs.oracle.com/javase/tutorial/datetime/iso/legacy.html">"Legacy Date-Time Code"</a>, The Java Tutorials. <a href="#fr-13-1">↩</a></p>
</li>
<li id="fn-14">
<p>Allen Wirfs-Brock, Brendan Eich, <a rel="external" href="https://dl.acm.org/doi/10.1145/3386327">"JavaScript: The First 20 Years"</a>, Proceedings of the ACM on Programming Languages, Volume 4, June 2020 (<a rel="external" href="https://js-history.vercel.app/">비공식 한국어 번역</a>). <a href="#fr-14-1">↩</a></p>
</li>
<li id="fn-15">
<p>Oracle, <a rel="external" href="https://docs.oracle.com/javase/8/docs/technotes/guides/datetime/index.html">"Java Date Time APIs"</a>, Java Platform, Standard Edition 8; JSR 310 Expert Group, <a rel="external" href="https://jcp.org/en/jsr/detail?id=310">"JSR 310: Date and Time API"</a>, Java Community Process. <a href="#fr-15-1">↩</a></p>
</li>
<li id="fn-16">
<p>TC39 Temporal Proposal, <a rel="external" href="https://github.com/tc39/proposal-temporal/issues/707">"What should be the long-term name of LocalDateTime?"</a>, GitHub Issue #707. <a href="#fr-16-1">↩</a></p>
</li>
<li id="fn-17">
<p>여러 시간 라이브러리에서 사용되는 <code>Local-</code> 네이밍은 C언어의 <a rel="external" href="https://en.cppreference.com/w/c/chrono/localtime.html"><code>localtime()</code></a> 함수에서 유래했을 것으로 추측한다. 표준처럼 굳어진 용어를 바꾸자는 주장에 마냥 동의하지는 않지만, <code>Local-</code>의 의미가 명확하지 않은 것은 사실이라 이 경우에는 이름을 바꾸는 결정이 합리적이라고 본다. <a href="#fr-17-1">↩</a></p>
</li>
</ol>
</section>

    </div>
</article>

<!-- For Utterances -->
<section class="comments">
    
    <noscript>댓글을 보려면 JavaScript를 활성화해주세요.</noscript>

    <script src="https://utteranc.es/client.js"
            repo="yangsijun528/sijun-yang.com"
            issue-term="pathname"
            label="utterances-comment"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    

    <div class="comments-skeleton"></div>

    <script>
        const observer = new MutationObserver(_ => {
            const utterances = document.querySelector('.utterances');
            if (utterances) {
                const height = utterances.offsetHeight;
                if (height > 200) {
                    document.querySelector('.comments').classList.add('comments-loaded');
                    observer.disconnect();
                }
            }
        });

        observer.observe(document.querySelector('.comments'), {
            childList: true, subtree: true, attributes: true, attributeFilter: ['style']
        });
    </script>
</section>

        </div>
    </main>

    <footer>
        <div class="width-wrapper">
            <p>
                Built with <a href="https://www.getzola.org/">Zola</a> -
                <a href="https://github.com/YangSiJun528/sijun-yang.com">Source Code</a>
            </p>
            <nav aria-label="Footer links">
                <ul>
                    <li><a href="/rss.xml">RSS</a></li>
                    <li><a href="/sitemap.xml">Sitemap</a></li>
                    <li><a href="/robots.txt">robots.txt</a></li>
                </ul>
            </nav>
        </div>
    </footer>
</body>
</html>
